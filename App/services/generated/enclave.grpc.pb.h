// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: enclave.proto
#ifndef GRPC_enclave_2eproto__INCLUDED
#define GRPC_enclave_2eproto__INCLUDED

#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

#include <functional>

#include "enclave.pb.h"

namespace rpc
{
class enclave final
{
 public:
  static constexpr char const* service_full_name() { return "rpc.enclave"; }
  class StubInterface
  {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status attest(::grpc::ClientContext* context,
                                  const ::rpc::Empty& request,
                                  ::rpc::Attestation* response) = 0;
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReaderInterface<::rpc::Attestation>>
    Asyncattest(::grpc::ClientContext* context,
                const ::rpc::Empty& request,
                ::grpc::CompletionQueue* cq)
    {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReaderInterface<::rpc::Attestation>>(
          AsyncattestRaw(context, request, cq));
    }
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReaderInterface<::rpc::Attestation>>
    PrepareAsyncattest(::grpc::ClientContext* context,
                       const ::rpc::Empty& request,
                       ::grpc::CompletionQueue* cq)
    {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReaderInterface<::rpc::Attestation>>(
          PrepareAsyncattestRaw(context, request, cq));
    }
    virtual ::grpc::Status status(::grpc::ClientContext* context,
                                  const ::rpc::Empty& request,
                                  ::rpc::Status* response) = 0;
    std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::rpc::Status>>
    Asyncstatus(::grpc::ClientContext* context,
                const ::rpc::Empty& request,
                ::grpc::CompletionQueue* cq)
    {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReaderInterface<::rpc::Status>>(
          AsyncstatusRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::rpc::Status>>
    PrepareAsyncstatus(::grpc::ClientContext* context,
                       const ::rpc::Empty& request,
                       ::grpc::CompletionQueue* cq)
    {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReaderInterface<::rpc::Status>>(
          PrepareAsyncstatusRaw(context, request, cq));
    }
    virtual ::grpc::Status process(::grpc::ClientContext* context,
                                   const ::rpc::Request& request,
                                   ::rpc::Response* response) = 0;
    std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::rpc::Response>>
    Asyncprocess(::grpc::ClientContext* context,
                 const ::rpc::Request& request,
                 ::grpc::CompletionQueue* cq)
    {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReaderInterface<::rpc::Response>>(
          AsyncprocessRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::rpc::Response>>
    PrepareAsyncprocess(::grpc::ClientContext* context,
                        const ::rpc::Request& request,
                        ::grpc::CompletionQueue* cq)
    {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReaderInterface<::rpc::Response>>(
          PrepareAsyncprocessRaw(context, request, cq));
    }
    class experimental_async_interface
    {
     public:
      virtual ~experimental_async_interface() {}
      virtual void attest(::grpc::ClientContext* context,
                          const ::rpc::Empty* request,
                          ::rpc::Attestation* response,
                          std::function<void(::grpc::Status)>) = 0;
      virtual void attest(::grpc::ClientContext* context,
                          const ::grpc::ByteBuffer* request,
                          ::rpc::Attestation* response,
                          std::function<void(::grpc::Status)>) = 0;
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void attest(::grpc::ClientContext* context,
                          const ::rpc::Empty* request,
                          ::rpc::Attestation* response,
                          ::grpc::ClientUnaryReactor* reactor) = 0;
#else
      virtual void attest(
          ::grpc::ClientContext* context,
          const ::rpc::Empty* request,
          ::rpc::Attestation* response,
          ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
#endif
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void attest(::grpc::ClientContext* context,
                          const ::grpc::ByteBuffer* request,
                          ::rpc::Attestation* response,
                          ::grpc::ClientUnaryReactor* reactor) = 0;
#else
      virtual void attest(
          ::grpc::ClientContext* context,
          const ::grpc::ByteBuffer* request,
          ::rpc::Attestation* response,
          ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
#endif
      virtual void status(::grpc::ClientContext* context,
                          const ::rpc::Empty* request,
                          ::rpc::Status* response,
                          std::function<void(::grpc::Status)>) = 0;
      virtual void status(::grpc::ClientContext* context,
                          const ::grpc::ByteBuffer* request,
                          ::rpc::Status* response,
                          std::function<void(::grpc::Status)>) = 0;
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void status(::grpc::ClientContext* context,
                          const ::rpc::Empty* request,
                          ::rpc::Status* response,
                          ::grpc::ClientUnaryReactor* reactor) = 0;
#else
      virtual void status(
          ::grpc::ClientContext* context,
          const ::rpc::Empty* request,
          ::rpc::Status* response,
          ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
#endif
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void status(::grpc::ClientContext* context,
                          const ::grpc::ByteBuffer* request,
                          ::rpc::Status* response,
                          ::grpc::ClientUnaryReactor* reactor) = 0;
#else
      virtual void status(
          ::grpc::ClientContext* context,
          const ::grpc::ByteBuffer* request,
          ::rpc::Status* response,
          ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
#endif
      virtual void process(::grpc::ClientContext* context,
                           const ::rpc::Request* request,
                           ::rpc::Response* response,
                           std::function<void(::grpc::Status)>) = 0;
      virtual void process(::grpc::ClientContext* context,
                           const ::grpc::ByteBuffer* request,
                           ::rpc::Response* response,
                           std::function<void(::grpc::Status)>) = 0;
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void process(::grpc::ClientContext* context,
                           const ::rpc::Request* request,
                           ::rpc::Response* response,
                           ::grpc::ClientUnaryReactor* reactor) = 0;
#else
      virtual void process(
          ::grpc::ClientContext* context,
          const ::rpc::Request* request,
          ::rpc::Response* response,
          ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
#endif
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void process(::grpc::ClientContext* context,
                           const ::grpc::ByteBuffer* request,
                           ::rpc::Response* response,
                           ::grpc::ClientUnaryReactor* reactor) = 0;
#else
      virtual void process(
          ::grpc::ClientContext* context,
          const ::grpc::ByteBuffer* request,
          ::rpc::Response* response,
          ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
#endif
    };
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
#endif
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
#endif
    virtual class experimental_async_interface* experimental_async()
    {
      return nullptr;
    }

   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface<::rpc::Attestation>*
    AsyncattestRaw(::grpc::ClientContext* context,
                   const ::rpc::Empty& request,
                   ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<::rpc::Attestation>*
    PrepareAsyncattestRaw(::grpc::ClientContext* context,
                          const ::rpc::Empty& request,
                          ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<::rpc::Status>*
    AsyncstatusRaw(::grpc::ClientContext* context,
                   const ::rpc::Empty& request,
                   ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<::rpc::Status>*
    PrepareAsyncstatusRaw(::grpc::ClientContext* context,
                          const ::rpc::Empty& request,
                          ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<::rpc::Response>*
    AsyncprocessRaw(::grpc::ClientContext* context,
                    const ::rpc::Request& request,
                    ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<::rpc::Response>*
    PrepareAsyncprocessRaw(::grpc::ClientContext* context,
                           const ::rpc::Request& request,
                           ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface
  {
   public:
    Stub(const std::shared_ptr<::grpc::ChannelInterface>& channel);
    ::grpc::Status attest(::grpc::ClientContext* context,
                          const ::rpc::Empty& request,
                          ::rpc::Attestation* response) override;
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::rpc::Attestation>>
    Asyncattest(::grpc::ClientContext* context,
                const ::rpc::Empty& request,
                ::grpc::CompletionQueue* cq)
    {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::rpc::Attestation>>(
          AsyncattestRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::rpc::Attestation>>
    PrepareAsyncattest(::grpc::ClientContext* context,
                       const ::rpc::Empty& request,
                       ::grpc::CompletionQueue* cq)
    {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::rpc::Attestation>>(
          PrepareAsyncattestRaw(context, request, cq));
    }
    ::grpc::Status status(::grpc::ClientContext* context,
                          const ::rpc::Empty& request,
                          ::rpc::Status* response) override;
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::rpc::Status>>
    Asyncstatus(::grpc::ClientContext* context,
                const ::rpc::Empty& request,
                ::grpc::CompletionQueue* cq)
    {
      return std::unique_ptr<::grpc::ClientAsyncResponseReader<::rpc::Status>>(
          AsyncstatusRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::rpc::Status>>
    PrepareAsyncstatus(::grpc::ClientContext* context,
                       const ::rpc::Empty& request,
                       ::grpc::CompletionQueue* cq)
    {
      return std::unique_ptr<::grpc::ClientAsyncResponseReader<::rpc::Status>>(
          PrepareAsyncstatusRaw(context, request, cq));
    }
    ::grpc::Status process(::grpc::ClientContext* context,
                           const ::rpc::Request& request,
                           ::rpc::Response* response) override;
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::rpc::Response>>
    Asyncprocess(::grpc::ClientContext* context,
                 const ::rpc::Request& request,
                 ::grpc::CompletionQueue* cq)
    {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::rpc::Response>>(
          AsyncprocessRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::rpc::Response>>
    PrepareAsyncprocess(::grpc::ClientContext* context,
                        const ::rpc::Request& request,
                        ::grpc::CompletionQueue* cq)
    {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::rpc::Response>>(
          PrepareAsyncprocessRaw(context, request, cq));
    }
    class experimental_async final
        : public StubInterface::experimental_async_interface
    {
     public:
      void attest(::grpc::ClientContext* context,
                  const ::rpc::Empty* request,
                  ::rpc::Attestation* response,
                  std::function<void(::grpc::Status)>) override;
      void attest(::grpc::ClientContext* context,
                  const ::grpc::ByteBuffer* request,
                  ::rpc::Attestation* response,
                  std::function<void(::grpc::Status)>) override;
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void attest(::grpc::ClientContext* context,
                  const ::rpc::Empty* request,
                  ::rpc::Attestation* response,
                  ::grpc::ClientUnaryReactor* reactor) override;
#else
      void attest(::grpc::ClientContext* context,
                  const ::rpc::Empty* request,
                  ::rpc::Attestation* response,
                  ::grpc::experimental::ClientUnaryReactor* reactor) override;
#endif
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void attest(::grpc::ClientContext* context,
                  const ::grpc::ByteBuffer* request,
                  ::rpc::Attestation* response,
                  ::grpc::ClientUnaryReactor* reactor) override;
#else
      void attest(::grpc::ClientContext* context,
                  const ::grpc::ByteBuffer* request,
                  ::rpc::Attestation* response,
                  ::grpc::experimental::ClientUnaryReactor* reactor) override;
#endif
      void status(::grpc::ClientContext* context,
                  const ::rpc::Empty* request,
                  ::rpc::Status* response,
                  std::function<void(::grpc::Status)>) override;
      void status(::grpc::ClientContext* context,
                  const ::grpc::ByteBuffer* request,
                  ::rpc::Status* response,
                  std::function<void(::grpc::Status)>) override;
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void status(::grpc::ClientContext* context,
                  const ::rpc::Empty* request,
                  ::rpc::Status* response,
                  ::grpc::ClientUnaryReactor* reactor) override;
#else
      void status(::grpc::ClientContext* context,
                  const ::rpc::Empty* request,
                  ::rpc::Status* response,
                  ::grpc::experimental::ClientUnaryReactor* reactor) override;
#endif
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void status(::grpc::ClientContext* context,
                  const ::grpc::ByteBuffer* request,
                  ::rpc::Status* response,
                  ::grpc::ClientUnaryReactor* reactor) override;
#else
      void status(::grpc::ClientContext* context,
                  const ::grpc::ByteBuffer* request,
                  ::rpc::Status* response,
                  ::grpc::experimental::ClientUnaryReactor* reactor) override;
#endif
      void process(::grpc::ClientContext* context,
                   const ::rpc::Request* request,
                   ::rpc::Response* response,
                   std::function<void(::grpc::Status)>) override;
      void process(::grpc::ClientContext* context,
                   const ::grpc::ByteBuffer* request,
                   ::rpc::Response* response,
                   std::function<void(::grpc::Status)>) override;
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void process(::grpc::ClientContext* context,
                   const ::rpc::Request* request,
                   ::rpc::Response* response,
                   ::grpc::ClientUnaryReactor* reactor) override;
#else
      void process(::grpc::ClientContext* context,
                   const ::rpc::Request* request,
                   ::rpc::Response* response,
                   ::grpc::experimental::ClientUnaryReactor* reactor) override;
#endif
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void process(::grpc::ClientContext* context,
                   const ::grpc::ByteBuffer* request,
                   ::rpc::Response* response,
                   ::grpc::ClientUnaryReactor* reactor) override;
#else
      void process(::grpc::ClientContext* context,
                   const ::grpc::ByteBuffer* request,
                   ::rpc::Response* response,
                   ::grpc::experimental::ClientUnaryReactor* reactor) override;
#endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub) : stub_(stub) {}
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override
    {
      return &async_stub_;
    }

   private:
    std::shared_ptr<::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_
    {
      this
    };
    ::grpc::ClientAsyncResponseReader<::rpc::Attestation>* AsyncattestRaw(
        ::grpc::ClientContext* context,
        const ::rpc::Empty& request,
        ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader<::rpc::Attestation>*
    PrepareAsyncattestRaw(::grpc::ClientContext* context,
                          const ::rpc::Empty& request,
                          ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader<::rpc::Status>* AsyncstatusRaw(
        ::grpc::ClientContext* context,
        const ::rpc::Empty& request,
        ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader<::rpc::Status>* PrepareAsyncstatusRaw(
        ::grpc::ClientContext* context,
        const ::rpc::Empty& request,
        ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader<::rpc::Response>* AsyncprocessRaw(
        ::grpc::ClientContext* context,
        const ::rpc::Request& request,
        ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader<::rpc::Response>* PrepareAsyncprocessRaw(
        ::grpc::ClientContext* context,
        const ::rpc::Request& request,
        ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_attest_;
    const ::grpc::internal::RpcMethod rpcmethod_status_;
    const ::grpc::internal::RpcMethod rpcmethod_process_;
  };
  static std::unique_ptr<Stub> NewStub(
      const std::shared_ptr<::grpc::ChannelInterface>& channel,
      const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service
  {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status attest(::grpc::ServerContext* context,
                                  const ::rpc::Empty* request,
                                  ::rpc::Attestation* response);
    virtual ::grpc::Status status(::grpc::ServerContext* context,
                                  const ::rpc::Empty* request,
                                  ::rpc::Status* response);
    virtual ::grpc::Status process(::grpc::ServerContext* context,
                                   const ::rpc::Request* request,
                                   ::rpc::Response* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_attest : public BaseClass
  {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithAsyncMethod_attest() { ::grpc::Service::MarkMethodAsync(0); }
    ~WithAsyncMethod_attest() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status attest(::grpc::ServerContext* /*context*/,
                          const ::rpc::Empty* /*request*/,
                          ::rpc::Attestation* /*response*/) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestattest(
        ::grpc::ServerContext* context,
        ::rpc::Empty* request,
        ::grpc::ServerAsyncResponseWriter<::rpc::Attestation>* response,
        ::grpc::CompletionQueue* new_call_cq,
        ::grpc::ServerCompletionQueue* notification_cq,
        void* tag)
    {
      ::grpc::Service::RequestAsyncUnary(
          0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_status : public BaseClass
  {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithAsyncMethod_status() { ::grpc::Service::MarkMethodAsync(1); }
    ~WithAsyncMethod_status() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status status(::grpc::ServerContext* /*context*/,
                          const ::rpc::Empty* /*request*/,
                          ::rpc::Status* /*response*/) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststatus(
        ::grpc::ServerContext* context,
        ::rpc::Empty* request,
        ::grpc::ServerAsyncResponseWriter<::rpc::Status>* response,
        ::grpc::CompletionQueue* new_call_cq,
        ::grpc::ServerCompletionQueue* notification_cq,
        void* tag)
    {
      ::grpc::Service::RequestAsyncUnary(
          1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_process : public BaseClass
  {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithAsyncMethod_process() { ::grpc::Service::MarkMethodAsync(2); }
    ~WithAsyncMethod_process() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status process(::grpc::ServerContext* /*context*/,
                           const ::rpc::Request* /*request*/,
                           ::rpc::Response* /*response*/) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestprocess(
        ::grpc::ServerContext* context,
        ::rpc::Request* request,
        ::grpc::ServerAsyncResponseWriter<::rpc::Response>* response,
        ::grpc::CompletionQueue* new_call_cq,
        ::grpc::ServerCompletionQueue* notification_cq,
        void* tag)
    {
      ::grpc::Service::RequestAsyncUnary(
          2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_attest<
      WithAsyncMethod_status<WithAsyncMethod_process<Service>>>
      AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_attest : public BaseClass
  {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    ExperimentalWithCallbackMethod_attest()
    {
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
#else
      ::grpc::Service::experimental().
#endif
          MarkMethodCallback(
              0,
              new ::grpc_impl::internal::
                  CallbackUnaryHandler<::rpc::Empty, ::rpc::Attestation>(
                      [this](
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                          ::grpc::CallbackServerContext*
#else
                          ::grpc::experimental::CallbackServerContext*
#endif
                              context,
                          const ::rpc::Empty* request,
                          ::rpc::Attestation* response) {
                        return this->attest(context, request, response);
                      }));
    }
    void SetMessageAllocatorFor_attest(
        ::grpc::experimental::MessageAllocator<::rpc::Empty,
                                               ::rpc::Attestation>* allocator)
    {
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler =
          ::grpc::Service::GetHandler(0);
#else
      ::grpc::internal::MethodHandler* const handler =
          ::grpc::Service::experimental().GetHandler(0);
#endif
      static_cast<::grpc_impl::internal::
                      CallbackUnaryHandler<::rpc::Empty, ::rpc::Attestation>*>(
          handler)
          ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_attest() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status attest(::grpc::ServerContext* /*context*/,
                          const ::rpc::Empty* /*request*/,
                          ::rpc::Attestation* /*response*/) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* attest(
        ::grpc::CallbackServerContext* /*context*/,
        const ::rpc::Empty* /*request*/,
        ::rpc::Attestation* /*response*/)
#else
    virtual ::grpc::experimental::ServerUnaryReactor* attest(
        ::grpc::experimental::CallbackServerContext* /*context*/,
        const ::rpc::Empty* /*request*/,
        ::rpc::Attestation* /*response*/)
#endif
    {
      return nullptr;
    }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_status : public BaseClass
  {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    ExperimentalWithCallbackMethod_status()
    {
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
#else
      ::grpc::Service::experimental().
#endif
          MarkMethodCallback(
              1,
              new ::grpc_impl::internal::CallbackUnaryHandler<::rpc::Empty,
                                                              ::rpc::Status>(
                  [this](
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                      ::grpc::CallbackServerContext*
#else
                      ::grpc::experimental::CallbackServerContext*
#endif
                          context,
                      const ::rpc::Empty* request,
                      ::rpc::Status* response) {
                    return this->status(context, request, response);
                  }));
    }
    void SetMessageAllocatorFor_status(
        ::grpc::experimental::MessageAllocator<::rpc::Empty, ::rpc::Status>*
            allocator)
    {
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler =
          ::grpc::Service::GetHandler(1);
#else
      ::grpc::internal::MethodHandler* const handler =
          ::grpc::Service::experimental().GetHandler(1);
#endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler<::rpc::Empty,
                                                              ::rpc::Status>*>(
          handler)
          ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_status() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status status(::grpc::ServerContext* /*context*/,
                          const ::rpc::Empty* /*request*/,
                          ::rpc::Status* /*response*/) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* status(
        ::grpc::CallbackServerContext* /*context*/,
        const ::rpc::Empty* /*request*/,
        ::rpc::Status* /*response*/)
#else
    virtual ::grpc::experimental::ServerUnaryReactor* status(
        ::grpc::experimental::CallbackServerContext* /*context*/,
        const ::rpc::Empty* /*request*/,
        ::rpc::Status* /*response*/)
#endif
    {
      return nullptr;
    }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_process : public BaseClass
  {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    ExperimentalWithCallbackMethod_process()
    {
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
#else
      ::grpc::Service::experimental().
#endif
          MarkMethodCallback(
              2,
              new ::grpc_impl::internal::CallbackUnaryHandler<::rpc::Request,
                                                              ::rpc::Response>(
                  [this](
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                      ::grpc::CallbackServerContext*
#else
                      ::grpc::experimental::CallbackServerContext*
#endif
                          context,
                      const ::rpc::Request* request,
                      ::rpc::Response* response) {
                    return this->process(context, request, response);
                  }));
    }
    void SetMessageAllocatorFor_process(
        ::grpc::experimental::MessageAllocator<::rpc::Request, ::rpc::Response>*
            allocator)
    {
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler =
          ::grpc::Service::GetHandler(2);
#else
      ::grpc::internal::MethodHandler* const handler =
          ::grpc::Service::experimental().GetHandler(2);
#endif
      static_cast<::grpc_impl::internal::
                      CallbackUnaryHandler<::rpc::Request, ::rpc::Response>*>(
          handler)
          ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_process() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status process(::grpc::ServerContext* /*context*/,
                           const ::rpc::Request* /*request*/,
                           ::rpc::Response* /*response*/) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* process(
        ::grpc::CallbackServerContext* /*context*/,
        const ::rpc::Request* /*request*/,
        ::rpc::Response* /*response*/)
#else
    virtual ::grpc::experimental::ServerUnaryReactor* process(
        ::grpc::experimental::CallbackServerContext* /*context*/,
        const ::rpc::Request* /*request*/,
        ::rpc::Response* /*response*/)
#endif
    {
      return nullptr;
    }
  };
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_attest<
      ExperimentalWithCallbackMethod_status<
          ExperimentalWithCallbackMethod_process<Service>>>
      CallbackService;
#endif

  typedef ExperimentalWithCallbackMethod_attest<
      ExperimentalWithCallbackMethod_status<
          ExperimentalWithCallbackMethod_process<Service>>>
      ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_attest : public BaseClass
  {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithGenericMethod_attest() { ::grpc::Service::MarkMethodGeneric(0); }
    ~WithGenericMethod_attest() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status attest(::grpc::ServerContext* /*context*/,
                          const ::rpc::Empty* /*request*/,
                          ::rpc::Attestation* /*response*/) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_status : public BaseClass
  {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithGenericMethod_status() { ::grpc::Service::MarkMethodGeneric(1); }
    ~WithGenericMethod_status() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status status(::grpc::ServerContext* /*context*/,
                          const ::rpc::Empty* /*request*/,
                          ::rpc::Status* /*response*/) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_process : public BaseClass
  {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithGenericMethod_process() { ::grpc::Service::MarkMethodGeneric(2); }
    ~WithGenericMethod_process() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status process(::grpc::ServerContext* /*context*/,
                           const ::rpc::Request* /*request*/,
                           ::rpc::Response* /*response*/) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_attest : public BaseClass
  {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithRawMethod_attest() { ::grpc::Service::MarkMethodRaw(0); }
    ~WithRawMethod_attest() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status attest(::grpc::ServerContext* /*context*/,
                          const ::rpc::Empty* /*request*/,
                          ::rpc::Attestation* /*response*/) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestattest(
        ::grpc::ServerContext* context,
        ::grpc::ByteBuffer* request,
        ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response,
        ::grpc::CompletionQueue* new_call_cq,
        ::grpc::ServerCompletionQueue* notification_cq,
        void* tag)
    {
      ::grpc::Service::RequestAsyncUnary(
          0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_status : public BaseClass
  {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithRawMethod_status() { ::grpc::Service::MarkMethodRaw(1); }
    ~WithRawMethod_status() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status status(::grpc::ServerContext* /*context*/,
                          const ::rpc::Empty* /*request*/,
                          ::rpc::Status* /*response*/) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststatus(
        ::grpc::ServerContext* context,
        ::grpc::ByteBuffer* request,
        ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response,
        ::grpc::CompletionQueue* new_call_cq,
        ::grpc::ServerCompletionQueue* notification_cq,
        void* tag)
    {
      ::grpc::Service::RequestAsyncUnary(
          1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_process : public BaseClass
  {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithRawMethod_process() { ::grpc::Service::MarkMethodRaw(2); }
    ~WithRawMethod_process() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status process(::grpc::ServerContext* /*context*/,
                           const ::rpc::Request* /*request*/,
                           ::rpc::Response* /*response*/) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestprocess(
        ::grpc::ServerContext* context,
        ::grpc::ByteBuffer* request,
        ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response,
        ::grpc::CompletionQueue* new_call_cq,
        ::grpc::ServerCompletionQueue* notification_cq,
        void* tag)
    {
      ::grpc::Service::RequestAsyncUnary(
          2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_attest : public BaseClass
  {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    ExperimentalWithRawCallbackMethod_attest()
    {
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
#else
      ::grpc::Service::experimental().
#endif
          MarkMethodRawCallback(
              0,
              new ::grpc_impl::internal::
                  CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                      [this](
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                          ::grpc::CallbackServerContext*
#else
                          ::grpc::experimental::CallbackServerContext*
#endif
                              context,
                          const ::grpc::ByteBuffer* request,
                          ::grpc::ByteBuffer* response) {
                        return this->attest(context, request, response);
                      }));
    }
    ~ExperimentalWithRawCallbackMethod_attest() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status attest(::grpc::ServerContext* /*context*/,
                          const ::rpc::Empty* /*request*/,
                          ::rpc::Attestation* /*response*/) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* attest(
        ::grpc::CallbackServerContext* /*context*/,
        const ::grpc::ByteBuffer* /*request*/,
        ::grpc::ByteBuffer* /*response*/)
#else
    virtual ::grpc::experimental::ServerUnaryReactor* attest(
        ::grpc::experimental::CallbackServerContext* /*context*/,
        const ::grpc::ByteBuffer* /*request*/,
        ::grpc::ByteBuffer* /*response*/)
#endif
    {
      return nullptr;
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_status : public BaseClass
  {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    ExperimentalWithRawCallbackMethod_status()
    {
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
#else
      ::grpc::Service::experimental().
#endif
          MarkMethodRawCallback(
              1,
              new ::grpc_impl::internal::
                  CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                      [this](
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                          ::grpc::CallbackServerContext*
#else
                          ::grpc::experimental::CallbackServerContext*
#endif
                              context,
                          const ::grpc::ByteBuffer* request,
                          ::grpc::ByteBuffer* response) {
                        return this->status(context, request, response);
                      }));
    }
    ~ExperimentalWithRawCallbackMethod_status() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status status(::grpc::ServerContext* /*context*/,
                          const ::rpc::Empty* /*request*/,
                          ::rpc::Status* /*response*/) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* status(
        ::grpc::CallbackServerContext* /*context*/,
        const ::grpc::ByteBuffer* /*request*/,
        ::grpc::ByteBuffer* /*response*/)
#else
    virtual ::grpc::experimental::ServerUnaryReactor* status(
        ::grpc::experimental::CallbackServerContext* /*context*/,
        const ::grpc::ByteBuffer* /*request*/,
        ::grpc::ByteBuffer* /*response*/)
#endif
    {
      return nullptr;
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_process : public BaseClass
  {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    ExperimentalWithRawCallbackMethod_process()
    {
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
#else
      ::grpc::Service::experimental().
#endif
          MarkMethodRawCallback(
              2,
              new ::grpc_impl::internal::
                  CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                      [this](
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                          ::grpc::CallbackServerContext*
#else
                          ::grpc::experimental::CallbackServerContext*
#endif
                              context,
                          const ::grpc::ByteBuffer* request,
                          ::grpc::ByteBuffer* response) {
                        return this->process(context, request, response);
                      }));
    }
    ~ExperimentalWithRawCallbackMethod_process() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status process(::grpc::ServerContext* /*context*/,
                           const ::rpc::Request* /*request*/,
                           ::rpc::Response* /*response*/) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* process(
        ::grpc::CallbackServerContext* /*context*/,
        const ::grpc::ByteBuffer* /*request*/,
        ::grpc::ByteBuffer* /*response*/)
#else
    virtual ::grpc::experimental::ServerUnaryReactor* process(
        ::grpc::experimental::CallbackServerContext* /*context*/,
        const ::grpc::ByteBuffer* /*request*/,
        ::grpc::ByteBuffer* /*response*/)
#endif
    {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_attest : public BaseClass
  {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithStreamedUnaryMethod_attest()
    {
      ::grpc::Service::MarkMethodStreamed(
          0,
          new ::grpc::internal::StreamedUnaryHandler<::rpc::Empty,
                                                     ::rpc::Attestation>(
              [this](::grpc_impl::ServerContext* context,
                     ::grpc_impl::ServerUnaryStreamer<::rpc::Empty,
                                                      ::rpc::Attestation>*
                         streamer) {
                return this->Streamedattest(context, streamer);
              }));
    }
    ~WithStreamedUnaryMethod_attest() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status attest(::grpc::ServerContext* /*context*/,
                          const ::rpc::Empty* /*request*/,
                          ::rpc::Attestation* /*response*/) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedattest(
        ::grpc::ServerContext* context,
        ::grpc::ServerUnaryStreamer<::rpc::Empty, ::rpc::Attestation>*
            server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_status : public BaseClass
  {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithStreamedUnaryMethod_status()
    {
      ::grpc::Service::MarkMethodStreamed(
          1,
          new ::grpc::internal::StreamedUnaryHandler<::rpc::Empty,
                                                     ::rpc::Status>(
              [this](
                  ::grpc_impl::ServerContext* context,
                  ::grpc_impl::ServerUnaryStreamer<::rpc::Empty, ::rpc::Status>*
                      streamer) {
                return this->Streamedstatus(context, streamer);
              }));
    }
    ~WithStreamedUnaryMethod_status() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status status(::grpc::ServerContext* /*context*/,
                          const ::rpc::Empty* /*request*/,
                          ::rpc::Status* /*response*/) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedstatus(
        ::grpc::ServerContext* context,
        ::grpc::ServerUnaryStreamer<::rpc::Empty, ::rpc::Status>*
            server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_process : public BaseClass
  {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

   public:
    WithStreamedUnaryMethod_process()
    {
      ::grpc::Service::MarkMethodStreamed(
          2,
          new ::grpc::internal::StreamedUnaryHandler<::rpc::Request,
                                                     ::rpc::Response>(
              [this](
                  ::grpc_impl::ServerContext* context,
                  ::grpc_impl::ServerUnaryStreamer<::rpc::Request,
                                                   ::rpc::Response>* streamer) {
                return this->Streamedprocess(context, streamer);
              }));
    }
    ~WithStreamedUnaryMethod_process() override
    {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status process(::grpc::ServerContext* /*context*/,
                           const ::rpc::Request* /*request*/,
                           ::rpc::Response* /*response*/) override
    {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedprocess(
        ::grpc::ServerContext* context,
        ::grpc::ServerUnaryStreamer<::rpc::Request, ::rpc::Response>*
            server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_attest<
      WithStreamedUnaryMethod_status<WithStreamedUnaryMethod_process<Service>>>
      StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_attest<
      WithStreamedUnaryMethod_status<WithStreamedUnaryMethod_process<Service>>>
      StreamedService;
};

}  // namespace rpc

#endif  // GRPC_enclave_2eproto__INCLUDED
